/**
 * Simple wrapper to contain log entries utilized in the 
 * request pipeline.
 * 
 * @export
 * @interface ILogEntry
 */
export interface ILogEntry {
    /**
     * The level of the log entry
     *
     * @type {LogLevel}
     * @memberof ILogEntry
     */
    logLevel: LogLevel;

    /**
     * The message to log
     *
     * @type {string}
     * @memberof ILogEntry
     */
    message: string;
}

/**
 * Context object that is passed through the fetch request pipeline. 
 * This object contains all information relevant to the given request
 * including the request, response and FetchEvent instance.
 *
 * @export
 * @interface IFetchContext
 */
export interface IFetchContext {
    /**
     * The request generated by the fetch call 
     *
     * @type {Request}
     * @memberof IFetchContext
     */
    request: Request;

    /**
     * The resulting response promise
     *
     * @type {Promise<Response>}
     * @memberof IFetchContext
     */
    response: Promise<Response>;
    
    /**
     * The FetchEvent object generated by the fetch call
     *
     * @type {FetchEvent}
     * @memberof IFetchContext
     */
    event: FetchEvent;
    
    /**
     * The service provider used to get service instances
     *
     * @type {IServiceProvider}
     * @memberof IFetchContext
     */
    serviceProvider: IServiceProvider;
    
    /**
     * Log entries to be grouped with others in the fetch call
     *
     * @type {ILogEntry[]}
     * @memberof IFetchContext
     */
    logEntries: ILogEntry[];

    /**
     * Store a new log entry
     *
     * @param {LogLevel} logLevel
     * @param {string} message
     * @memberof IFetchContext
     */
    log(logLevel: LogLevel, message: string): void;
}

/**
 * Defines the method to be used during the request pipeline
 *
 * @export
 * @type RequestDelegate
 */
export type RequestDelegate = (fetchContext: IFetchContext) => Promise<IFetchContext>;

/**
 * Type used to support middleware utilized in the request pipeline
 *
 * @export
 * @interface IMiddleware
 */
export interface IMiddleware {
    /**
     * Next RequestDelegate to be called after local work is completed
     *
     * @type {RequestDelegate}
     * @memberof IMiddleware
     */
    next: RequestDelegate;

    /**
     * The logic of the middleware. This is called during the request pipeline.
     *
     * @param {IFetchContext} fetchContext
     * @returns {Promise<IFetchContext>}
     * @memberof IMiddleware
     */
    invokeAsync(fetchContext: IFetchContext): Promise<IFetchContext>;
}

/**
 * Used to create the request pipeline. This interface is intended to be extended
 * to accommodate additional functionality in the future. Refer to extension implementations
 * found in the documentation for examples.
 *
 * @export
 * @interface IApplicationBuilder
 */
export interface IApplicationBuilder {
    /**
     * The final RequestDelegate to be called when no other RequestDelegate
     * terminates the request pipeline.
     *
     * @type {RequestDelegate}
     * @memberof IApplicationBuilder
     */
    defaultRequestDelegate: RequestDelegate;
    
    /**
     * Configuration object
     *
     * @type {IServiceWorkerConfiguration}
     * @memberof IApplicationBuilder
     */
    config: IServiceWorkerConfiguration;

    /**
     * Service provider used by middleware to obtain service instances
     *
     * @type {IServiceProvider}
     * @memberof IApplicationBuilder
     */
    applicationServices: IServiceProvider;

    /**
     * Sets an object to be shared between middleware implementations
     *
     * @template T
     * @param {string} key
     * @param {T} value
     * @memberof IApplicationBuilder
     */
    setProperty<T extends object>(key: string, value: T): void;
    
    /**
     * Gets an object to be shared between middleware implementations
     *
     * @template T
     * @param {string} key
     * @returns {T}
     * @memberof IApplicationBuilder
     */
    getProperty<T extends object>(key: string): T;
    
    /**
     * Clones the current instance of an IApplicationBuilder
     *
     * @returns {IApplicationBuilder}
     * @memberof IApplicationBuilder
     */
    clone(): IApplicationBuilder;

    /**
     * Builds the request pipeline. This should be called during the Activate event 
     * and stored for later use during any subsequent Fetch event.
     *
     * @returns {RequestDelegate}
     * @memberof IApplicationBuilder
     */
    build(): RequestDelegate;

    /**
     * Adds a pass through a middleware to be used.
     *
     * @param {(requestDelegate: RequestDelegate) => RequestDelegate} middleware
     * @returns {IApplicationBuilder}
     * @memberof IApplicationBuilder
     */
    use(middleware: (requestDelegate: RequestDelegate) => RequestDelegate): IApplicationBuilder;

    /**
     * Adds a pass through middleware to be used.
     *
     * @param {(fetchContext: IFetchContext, next: () => Promise<IFetchContext>) => Promise<IFetchContext>} middleware
     * @returns {IApplicationBuilder}
     * @memberof IApplicationBuilder
     */
    useNext(middleware: (fetchContext: IFetchContext, next: () => Promise<IFetchContext>) => Promise<IFetchContext>): IApplicationBuilder;

    /**
     * Adds a terminal middleware implementation.
     *
     * @param {RequestDelegate} handler
     * @memberof IApplicationBuilder
     */
    run(handler: RequestDelegate): void;
}

/**
 * Defines a class to have a constructor containing a request delegate as the first parameter
 * and resulting in an IMiddleware
 *
 * @export
 * @type MiddlewareFactory
 */
export type MiddlewareFactory<T extends IMiddleware> = { new(next: RequestDelegate, ...args: any[]): T; };

/**
 * Defines the lifetime of a service
 *
 * @export
 * @enum {number}
 */
export enum ServiceLifetime {
    /**
     * New instance every call
     */
    Transient,

    /**
     * One instance per fetch request pipeline
     */
    Scoped,

    /**
     * One instance per service worker
     */
    Singleton,
}

/**
 * Describes a service definition
 *
 * @export
 * @interface IServiceDescriptor
 */
export interface IServiceDescriptor {
    /**
     * How long the service should live
     *
     * @type {ServiceLifetime}
     * @memberof IServiceDescriptor
     */
    lifetime: ServiceLifetime;

    /**
     * Factory method
     *
     * @memberof IServiceDescriptor
     */
    factory: () => object;
    
    /**
     * Unique key used to reference the type
     *
     * @type {string}
     * @memberof IServiceDescriptor
     */
    key: string;
}

export interface IServiceCollection {
    serviceDescriptors: Map<string, IServiceDescriptor>;

    addTransient<T extends object>(key: string, factory: () => T): void;
    addScoped<T extends object>(key: string, factory: () => T): void;
    addSingleton<T extends object>(key: string, factory: () => T): void;
}

export interface IServiceProvider {
    getInstance<T extends object>(key: string): T;
    resetScope(): void;
}

export interface IStartup {
    configure(applicationBuilder: IApplicationBuilder): void;
    configureServices?(services: IServiceCollection, logger?: ILogger): void;
}

export type StartupFactory<T extends IStartup> = { new(): T };

export interface IServiceWorkerBuilder {
    configureLogging(configuration: (builder: ILoggingBuilder) => void): IServiceWorkerBuilder;
    useStartup<T extends IStartup>(startupType: StartupFactory<T>): IServiceWorkerBuilder;
    build(): void;
}

export interface IServiceWorkerConfiguration {
    version: string;
    origin?: string;
    environment?: "production" | "development";
}

export interface ICacheClearOptions {
    whitelist: string[];
}

export interface IApplicationLifetime {
    activating: IEventToken;
    installing: IEventToken;
}

export interface IEventToken {
    register(handler: (event: ExtendableEvent) => Promise<void>): void;
}

export interface ILoggingBuilder {
    logLevel: LogLevel | null;
    loggerFactory: (() => ILogger) | null;
}

export interface ILogger {
    logLevel: LogLevel;

    isDebug: boolean;
    isInfo: boolean;
    isWarn: boolean;

    debug(message: string): void;
    info(message: string): void;
    warn(message: string): void;
    error(message: string): void;

    group(title: string, message?: string, logLevel?: LogLevel): void;
    groupCollapsed(title: string, message?: string, logLevel?: LogLevel): void;
    groupEnd(): void;
}

export enum LogLevel {
    None = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
}

export type CacheStrategy = (key?: string) => (fetchContext: IFetchContext) => Promise<Response>;

export interface ICacheStrategies {
    networkOnly: CacheStrategy;
    cacheOnly: CacheStrategy;
    cacheFirst: CacheStrategy;
    networkFirst: CacheStrategy;
    backgroundFetch: CacheStrategy;
}
